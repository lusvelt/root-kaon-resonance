\DeclareUnicodeCharacter{2212}{-}
\DeclareUnicodeCharacter{3C0}{$\pi$}
\documentclass{article}
\usepackage[utf8]{inputenc}
\usepackage{graphicx}
\usepackage{amsmath}
\usepackage[font=small,labelfont=bf]{caption}
\usepackage[a4paper]{geometry}
\usepackage{minted}
\usepackage{tikz}
\usepackage{tikz-uml}
\usepackage[italian]{babel}
\usepackage{tikzscale}

\title{Relazione di Laboratorio - C++/ROOT}
\author{Damiano Scevola}
\date{16/11/2021}

\begin{document}

\maketitle

\section{Introduzione}
Il programma descritto nella presente relazione ha lo scopo di simulare ed analizzare eventi fisici risultanti da collisioni di particelle elementari. Nello specifico, ci proponiamo di generare un numero statisticamente significativo di eventi in ognuno dei quali più particelle di diverso tipo e con impulsi diversi collidono tra loro. Alcune di queste particelle sono risonanze, e a causa della loro natura instabile decadono in altre particelle elementari. Analizzando le distribuzioni di massa invariante, si rileva il segnale delle risonanze, da cui si possono ricavare la massa e la larghezza che risultano compatibili con quelle imposte in fase di generazione.

\section{Struttura del Codice}
Il codice è strutturato in tre classi (\texttt{ParticleType}, \texttt{ResonanceType} e \texttt{Particle}), due macro (\texttt{GenerateParticles} e \texttt{AnalyzeData}) e un file di definizione delle costanti utilizzate per favorire la leggibilità del codice (\texttt{Parameters.h}). In appendice è riportato il listato del codice.

\begin{figure}[h!]
\centering
\begin{tikzpicture}
\umlclass[x=0, y=0]{ParticleType}{
    \# fName : const string \\
    \# fMass : const double \\
    \# fCharge : const int
}{
    + ParticleType(name : const string, \\
                   mass : const double, charge: const int) \\
    + GetName() : string «const» \\
    + GetMass() : double «const» \\
    + GetCharge() : int «const» \\
    \umlvirt{+ GetWidth() : double «const»} \\
    \umlvirt{+ Print() : void «const»}
}
\umlclass[x=0, y=-5]{ResonanceType}{
    -- fWidth : const double
}{
    + ResonanceType(name : const string, \\
        mass: const double, charge: const int, \\
        width : const double) \\
    + GetWidth() : double «const» \\
    + Print() : void «const»
}
\umlinherit{ResonanceType}{ParticleType}
\umlclass[x=8, y=-2]{Particle}{
    -- fIndex : int \\
    -- fPx : double \\
    -- fPy : double \\
    -- fPz : double \\
    \umlstatic{-- fMaxNumParticleType : const int = 10} \\
    \umlstatic{-- fParticleType : const ParticleType*[]} \\
    \umlstatic{-- fNParticleType : int}
}{
    + Particle() \\
    + Particle(particleName : string, \\
        Px : double, Py : double, Pz : double) \\
    + GetIndex() : int «const» \\
    + GetParticleType() : \\
        const ParticleType* «const» \\
    + SetIndex(index : int) : void \\
    + SetIndex(particleName : string) : void\\
    + Print() : void «const» \\
    + GetPx() : double «const» \\
    + GetPy() : double «const» \\
    + GetPz() : double «const» \\
    + GetMass() : double «const» \\
    + TotEnergy() : double «const» \\
    + InvMass(p : Particle*) : \\ 
        double «const» \\
    + SetP(Px : double, Py : double, \\
        Pz : double) : void \\
    + Decay2Body(dau1 : Particle\&, dau2 : \\
        Particle\&) : int «const» \\
    \umlstatic{+ AddParticleType(particleName : string, } \\
    \umlstatic{mass : const double, charge : const int, } \\
    \umlstatic{width : const double = 0) : void} \\
    \umlstatic{+ PrintParticleTypes() : void} \\
    -- Boost(bx : double, by : double, \\
        bz : double) : void \\
    \umlstatic{-- FindParticle(particleName : string) : int}
}
\umlcompo[geometry=-|-]{Particle}{ParticleType}
%\umlcompo[geometry=-|-, anchor1=-150]{Particle}{ResonanceType}
\end{tikzpicture}
\caption{Diagramma UML delle classi: \texttt{ResonanceType} eredita da \texttt{ParticleType} e \texttt{Particle} ha un attributo statico che per composizione è un array contenente istanze delle due classi precedenti. Secondo la notazione UML, i membri contrassegnati con + sono \textit{public}, quelli con -- \textit{private} e quelli con \# \textit{protected}. Il tipo è indicato dopo i due punti. I membri \underline{sottolineati} sono \textit{static} e quelli \textit{corsivo} sono \textit{virtual}.}
\label{fig:uml}
\end{figure}

Come mostrato nella figura \ref{fig:uml}, che riporta il diagramma delle classi, \texttt{ResonanceType} eredita da \texttt{ParticleType} poichè legate concettualmente da una relazione ``\textit{is a}'', infatti ogni risonanza \textit{è una} particella. La classe \texttt{Particle} è invece legata per composizione a \texttt{ParticleType} attraverso l'attributo statico \texttt{fParticleType}, che è un array di puntatori ad oggetti di tipo \texttt{ParticleType}. Poichè \texttt{ResonanceType} estende \texttt{ParticleType}, gli elementi all'interno di \texttt{fParticleType} possono essere anche di tipo \texttt{ResonanceType}, la relazione di composizione si estende anche a quest'ultima classe.

Le classi \texttt{ParticleType} e \texttt{ResonanceType} rappresentano un determinato tipo di particella, con nome (\texttt{fName}), massa (\texttt{fMass}), carica (\texttt{fCharge}) ed eventualmente larghezza (\texttt{fWidth}). I relativi attributi sono dichiarati \texttt{const} poichè una volta inizializzati non possono essere modificati durante l'esecuzione, essendo caratteristiche intrinseche del tipo di particella considerato. I metodi costruttori si occupano quindi di inizializzare tali attributi mediante liste di inizializzazione. Come di norma, gli attributi della classe padre sono dichiarati con visibilità \texttt{protected} per permettere alla classe figlia di accedervi, e quelli di quest'ultima \texttt{private}. Per ottenere o il valore di tali attributi
sono presenti i metodi getter. Sono presenti inoltre i metodi \texttt{Print()} per stampare su terminale i vari attributi. Da notare infine che i metodi \texttt{GetWidth} e \texttt{Print} sono \texttt{virtual} per garantire il polimorfismo degli oggetti di tipo \texttt{ResonanceType} quando si accede agli elementi dell'array \texttt{fParticleType}, dichiarato di tipo \texttt{ParticleType*}.

La classe \texttt{Particle} rappresenta, invece, una particella vera e propria, infatti sono presenti gli attributi relativi alle tre componenti dell'impulso \texttt{fPx}, \texttt{fPy} e \texttt{fPz} con i relativi metodi getter e setter. Per definire i tipi delle particelle è presente il metodo \texttt{AddParticleType}, che aggiunge un elemento (di tipo \texttt{ResonanceType} se la larghezza non è nulla, \texttt{ParticleType} altrimenti) all'array \texttt{fParticleType}. Il numero di elementi contenuti al suo interno è pari al valore di \texttt{fNParticleType}, che può arrivare al massimo a \texttt{fMaxNumParticleType}, e il contenuto dell'array può essere stampato su terminale con il metodo statico \texttt{PrintParticleTypes}. Ogni particella istanziata avrà un determinato tipo a seconda del valore dell'attributo \texttt{fIndex}, che rappresenta l'indice del tipo della particella nell'array \texttt{fParticleType} e che viene settato con il metodo \texttt{SetIndex}, di cui sono presenti due overload. Per ottenere l'indice di un tipo di particella a partire dalla stringa del suo nome è presente il metodo \texttt{FindParticle}.

Oltre al metodo \texttt{Print}, che serve per stampare su terminale il tipo e l'impulso della particella, sono presenti i metodi \texttt{GetMass} e \texttt{TotEnergy}, che restituiscono rispettivamente la massa (data dal tipo) e l'energia relativistica della particella. Il metodo \texttt{InvMass}, invece, restituisce la massa invariante del sistema costituito dalla particella attuale e da quella passata come parametro. Il metodo \texttt{Decay2Body}, infine, presi come parametri per riferimento due oggetti di tipo \texttt{Particle}, simula il decadimento della particella e inserisce in essi i dati delle figlie, richiamando il metodo \texttt{Boost} durante la procedura.

\section{Generazione}
All'inizio della macro \texttt{GenerateParticles} viene chiamato il metodo \texttt{AddParticleType} una volta per ognuno dei 7 tipi di particelle considerati nella simulazione. Successivamente, dopo aver dichiarato e configurato gli istogrammi da riempire durante l'esecuzione, vengono simulati $10^5$ eventi, in ognuno dei quali sono coinvolte $100$ particelle iniziali, generate casualmente secondo definite proporzioni come segue:
\begin{itemize}
    \item 40\% Pioni positivi ($\pi+$)
    \item 40\% Pioni negativi ($\pi-$)
    \item 5\% Kaoni positivi (K+)
    \item 5\% Kaoni negativi (K--)
    \item 4.5\% Protoni positivi (p+)
    \item 4.5\% Protoni negativi (p--)
    \item 1\% Kaoni risonanza (K*)
\end{itemize}
Per ogni particella vengono calcolate le tre componenti dell'impulso $\overrightarrow{P}=(P_x, P_y, P_z)$ a partire dalle coordinate polari $(|P|, \theta, \phi)$ generate casualmente come segue:
\begin{itemize}
    \item il modulo $|P|$ ha distribuzione esponenziale di valor medio $1$ GeV/c
    \item l'angolo polare $\theta$ ha distribuzione uniforme in $[0, \pi]$
    \item l'angolo azimutale $\phi$ ha distribuzione uniforme in $[0, 2\pi]$
\end{itemize}
Per calcolare le componenti di $\overrightarrow{P}$ si usano le consuete relazioni:
\begin{align*}
    P_x &= |P| sin \theta cos \phi \\
    P_y &= |P| sin \theta sin \phi \\
    P_z &= |P| cos \theta
\end{align*}

Una volta stabilito il tipo e l'impulso della particella, nel caso in cui si tratti di una K* occorre farla decadere in una delle due coppie $\{\pi+, K-\}$ o $\{\pi-, K+\}$ con uguale probabilità.

Dopo aver simulato le interazioni calcolando i valori di massa invariante di tutte le possibili coppie di particelle presenti dopo i decadimenti, i dati vengono inseriti negli istogrammi e salvati in un file ROOT.

\section{Analisi}
La macro \texttt{AnalyzeData} si occupa di leggere ed elaborare il contenuto del file ROOT contenente i dati simulati mediante l'esecuzione di \texttt{GenerateParticles}. Osservando i grafici prodotti si possono effettuare le dovute considerazioni.

Innanzitutto verifichiamo, come mostrato qualitativamente nell'istogramma in alto a sx in figura \ref{fig:tipi} e quantitativamente nella tabella \ref{table:tipi}, che i tipi delle particelle generate nella simulazione rispettano le proporzioni definite precedentemente, in particolare tutti i valori attesi si trovano entro $2\sigma$ dal valore osservato.

\begin{table}[h]
    \centering
    \begin{tabular}{||c|c|c||}
        \hline
            Specie & Occ. Osservate & Occ. Attese \\
        \hline \hline
            $\pi+$ & $4001420 \pm 2000$ & $4000000$ \\
        \hline
            $\pi-$ & $3998890 \pm 2000$ & $4000000$ \\
        \hline
            K+ & $499229 \pm 707$ & $500000$ \\
        \hline
            K- & $499292 \pm 707$ & $500000$ \\
        \hline
            p+ & $449712 \pm 671$ & $450000$ \\
        \hline
            p- & $450991 \pm 672$ & $450000$ \\
        \hline
            K* & $100466 \pm 317$ & $100000$ \\
        \hline
    \end{tabular}
    \caption{Occorrenze osservate e attese dei tipi di particelle}
    \label{table:tipi}
\end{table}

\begin{figure}[hb!]
    \centering
    \includegraphics[width=\textwidth]{histograms/typesAndMomentum}
    \caption{In alto a sx: istogramma dei tipi di particelle generati. I tre istogrammi rimanenti raffigurano le occorrenze delle coordinate polari dell'impulso. I fit sono rapresentati in rosso.}
    \label{fig:tipi}
\end{figure}

Analizzando, invece, i grafici delle coordinate polari dell'impulso (sempre in figura \ref{fig:tipi}) e la relativa tabella \ref{table:impulso}, si nota come i fit delle distribuzioni siano visivamente e quantitativamente compatibili con esse, tenendo conto dei valori $\chi^2$ rispetto ai gradi di libertà e delle probabilità. In particolare il parametro (media) del fit esponenziale sul modulo dell'impulso risulta compatibile, entro $1\sigma$, con il valore impostato in fase di generazione di $1.0$ GeV/c.

\begin{table}[h]
    \centering
    \begin{tabular}{||c|c|c|c|c||}
        \hline
        Distribuzione & Parametri Fit & $\chi^2$ & DOF & $\chi^2$/DOF \\
        \hline \hline
        Angolo Polare $\theta$ & $(0.3183 \pm 0.0001)\ rad$ & 42.98 & 49 & 0.8771 \\
        \hline
        Angolo Azimutale $\phi$ & $(0.1592 \pm 0.0001)\ rad$ & 44.59 & 49 & 0.9100 \\
        \hline
        Modulo Impulso $|P|$ & $(0.9998 \pm 0.0003)\ GeV/c$ & 34.32 & 48 & 0.7150 \\
        \hline
    \end{tabular}
    \caption{Dati relativi ai fit, uniformi per le distribuzioni degli angoli direzionali, ed esponenziale per quella del modulo dell'impulso.}
    \label{table:impulso}
\end{table}

Infine, passiamo ad analizzare i dati relativi ai valori di massa invariante. Per ottenere il segnale della risonanza K*, il cui picco effettivo è rappresentato nel primo grafico in figura \ref{fig:invMass}, si è fatto uso dei seguenti istogrammi:
\begin{enumerate}
    \item massa invariante tra le particelle di carica opposta
    \item massa invariante tra le particelle di carica uguale
    \item massa invariante tra pioni e kaoni di carica opposta
    \item massa invariante tra pioni e kaoni di carica uguale
\end{enumerate}
Poichè la massa invariante tra particelle di carica concorde è composta solo da combinazioni accidentali, mentre quella tra particelle di carica discorde coinvolge sia combinazioni accidentali, che il segnale della risonanza (che infatti quando decade genera un pione e un kaone di carica discorde), sottraendo l'istogramma 2 dall'1 (grafico centrale in figura \ref{fig:invMass}) otteniamo un picco proprio in corrispondenza della massa di K*, e lo stesso vale a maggior ragione se teniamo conto solamente dei pioni e dei kaoni, come si osserva nel grafico in basso (figura \ref{fig:invMass}). Osservando i dati nella tabella \ref{table:invMass} relativi alle distribuzioni normali ottenute facendo fit sugli istogrammi di massa invariante, le considerazioni visive appena effettuate sono confermate, in particolare si può notare che i valori medi sono compatibili entro $1\sigma$ con la massa reale di K*, pari a 0.89166 $GeV/c^2$, e i valori di $\sigma$ sono compatibili con la larghezza della risonanza entro 3 deviazioni standard.

\begin{table}[h]
    \centering
    \begin{tabular}{||c|c|c|c|c||}
        \hline
        Distribuzione & Media ($GeV/c^2$) & $\sigma\ (GeV/c^2)$ & Ampiezza ($GeV/c^2$) & $\chi^2/DOF$ \\
        \hline \hline
        Massa inv. K* & $(0.8918 \pm 0.0002)$ & $(0.0501 \pm 0.0001)$ & $(0.1504 \pm 0.0003)$ & 0.6061 \\
        \hline
        Discordi--Concordi & $(0.8922 \pm 0.0039)$ & $(0.0417 \pm 0.0038)$ & $(0.1251 \pm 0.0114)$ & 0.9363 \\
        \hline
        Disc.--Conc. ($\pi$, K) & $(0.8853 \pm 0.0027)$ & $(0.0514 \pm 0.0030)$ & $(0.1541 \pm 0.0090)$ & 0.9811 \\
        \hline
    \end{tabular}
    \caption{Dati relativi ai fit degli istogrammi di massa invariante, rappresentati nella figura \ref{fig:invMass}.}
    \label{table:invMass}
\end{table}

\begin{figure}
    \centering
    \includegraphics[width=\textwidth]{histograms/invMass}
    \caption{In alto: istogramma della massa invariante effettiva delle particelle K*, ottenuta combinando le figlie del decadimento. Al centro: differenza tra massa invariante di particelle con carica discorde e quella di particelle di carica concorde. In basso: differenza come nel caso precedente, ma tenendo conto solo dei pioni e dei kaoni.}
    \label{fig:invMass}
\end{figure}

\pagebreak

\section*{Appendice}
\subsection*{Parameters.h}
\begin{minted}[breaklines]{c}
#include <string>

using namespace std;

#ifndef PARAMETERS_H
#define PARAMETERS_H

const int N_PARTICLE_TYPES = 7;
const int N_ITERATIONS = 1E5;
const int N_PARTICLES_PER_ITERATION = 100;
const int MAX_PRODUCTS = 200;
const double AVG_P = 1.0;
const int N_BINS = 50;
const int N_BINS_INV_MASS = 100;
const double MAX_MOMENTUM = 5.0;
const double MAX_ENERGY = 8.0;
const double MIN_INVARIANT_MASS = 0.5;
const double MAX_INVARIANT_MASS = 1.5;

const int PION_PLUS_BIN = 1;
const int PION_MINUS_BIN = 2;
const int KAON_PLUS_BIN = 3;
const int KAON_MINUS_BIN = 4;
const int PROTON_PLUS_BIN = 5;
const int PROTON_MINUS_BIN = 6;
const int KAON_STAR_BIN = 7;

const double PION_PLUS_PROB = 0.4;
const double PION_MINUS_PROB = 0.4;
const double KAON_PLUS_PROB = 0.05;
const double KAON_MINUS_PROB = 0.05;
const double PROTON_PLUS_PROB = 0.045;
const double PROTON_MINUS_PROB = 0.045;
const double KAON_STAR_PROB = 0.01;

const double PROBABILITIES[] = {
    PION_PLUS_PROB,
    PION_MINUS_PROB,
    KAON_PLUS_PROB,
    KAON_MINUS_PROB,
    PROTON_PLUS_PROB,
    PROTON_MINUS_PROB,
    KAON_STAR_PROB
};

const string PION_PLUS_LABEL = "π+";
const string PION_MINUS_LABEL = "π-";
const string KAON_PLUS_LABEL = "K+";
const string KAON_MINUS_LABEL = "K-";
const string PROTON_PLUS_LABEL = "p+";
const string PROTON_MINUS_LABEL = "p-";
const string KAON_STAR_LABEL = "K*";

const string LABELS[] = {
    PION_PLUS_LABEL,
    PION_MINUS_LABEL,
    KAON_PLUS_LABEL,
    KAON_MINUS_LABEL,
    PROTON_PLUS_LABEL,
    PROTON_MINUS_LABEL,
    KAON_STAR_LABEL
};

const double PION_PLUS_CUMULATIVE = PION_PLUS_PROB;
const double PION_MINUS_CUMULATIVE = PION_PLUS_CUMULATIVE + PION_MINUS_PROB;
const double KAON_PLUS_CUMULATIVE = PION_MINUS_CUMULATIVE + KAON_PLUS_PROB;
const double KAON_MINUS_CUMULATIVE = KAON_PLUS_CUMULATIVE + KAON_MINUS_PROB;
const double PROTON_PLUS_CUMULATIVE = KAON_MINUS_CUMULATIVE + PROTON_PLUS_PROB;
const double PROTON_MINUS_CUMULATIVE = PROTON_PLUS_CUMULATIVE + PROTON_MINUS_PROB;
const double KAON_STAR_CUMULATIVE = PROTON_MINUS_CUMULATIVE + KAON_STAR_PROB;

#endif
\end{minted}

\subsection*{ParticleType.h}
\begin{minted}[breaklines]{c}
#ifndef PARTICLE_TYPE_H
#define PARTICLE_TYPE_H

using namespace std;

class ParticleType {
    public:
        ParticleType(const string name, const double mass, const int charge) :
            fName(name), fMass(mass), fCharge(charge) {}
        string GetName() const;
        double GetMass() const;
        int GetCharge() const;
        virtual double GetWidth() const;
        virtual void Print() const;

    protected:
        const string fName;
        const double fMass;
        const int fCharge;
};

#endif
\end{minted}

\subsection*{ParticleType.cpp}
\begin{minted}[breaklines]{c}
#include "ParticleType.h"

#include <iostream>

using namespace std;

string ParticleType::GetName() const {
    return fName;
}

double ParticleType::GetMass() const {
    return fMass;
}

int ParticleType::GetCharge() const {
    return fCharge;
}

double ParticleType::GetWidth() const {
    return 0;
}

void ParticleType::Print() const {
    std::cout << "Particle Type: " << fName << std::endl <<
                 "\tMass = " << fMass << " MeV/c^2" << std::endl <<
                 "\tCharge = " << fCharge << " e" << std::endl;
}
\end{minted}

\subsection*{ResonanceType.h}
\begin{minted}[breaklines]{c}
#include "ParticleType.h"

#ifndef RESONANCE_TYPE_H
#define RESONANCE_TYPE_H

using namespace std;

class ResonanceType : public ParticleType {
    public:
        ResonanceType(const string name, const double mass, const int charge, const double width) :
            ParticleType(name, mass, charge), fWidth(width) {}
        double GetWidth() const;
        void Print() const;
        
    private:
        const double fWidth;
};

#endif
\end{minted}

\subsection*{ResonanceType.cpp}
\begin{minted}[breaklines]{c}
#include "ResonanceType.h"

#include "ParticleType.h"
#include <iostream>

double ResonanceType::GetWidth() const {
    return fWidth;
}

void ResonanceType::Print() const {
    ParticleType::Print();
    std::cout << "\tWidth = " << fWidth << " s^-1" << std::endl;
}
\end{minted}

\subsection*{Particle.h}
\begin{minted}[breaklines]{c}
#include "ParticleType.h"

#ifndef PARTICLE_H
#define PARTICLE_H

using namespace std;

class Particle {
    public:
        Particle();
        Particle(string particleName, double Px, double Py, double Pz);
        int GetIndex() const;
        const ParticleType *GetParticleType() const;
        void SetIndex(int index);
        void SetIndex(string particleName);
        void Print() const;
        double GetPx() const;
        double GetPy() const;
        double GetPz() const;
        double GetMass() const;
        double TotEnergy() const;
        double InvMass(Particle *p) const;
        void SetP(double Px, double Py, double Pz);
        int Decay2Body(Particle &dau1, Particle &dau2) const;

        static void AddParticleType(string particleName, const double mass, const int charge, const double width = 0);
        static void PrintParticleTypes();

    private:
        int fIndex;
        double fPx, fPy, fPz;

        static const int fMaxNumParticleType = 10;
        static const ParticleType *fParticleType[];
        static int fNParticleType;

        static int FindParticle(string particleName);

        void Boost(double bx, double by, double bz);
};

#endif
\end{minted}

\subsection*{Particle.cpp}
\begin{minted}[breaklines]{c}
#include "Particle.h"

#include "ParticleType.h"
#include "ResonanceType.h"
#include <string>
#include <iostream>
#include <cmath>
#include <cstdlib>

using namespace std;

int Particle::fNParticleType = 0;
const ParticleType *Particle::fParticleType[Particle::fMaxNumParticleType];

int Particle::FindParticle(string particleName) {
    for (int i = 0; i < fNParticleType; i++)
        if (fParticleType[i]->GetName() == particleName)
            return i;
    return -1;
}

Particle::Particle() {
    fIndex = -1;
}

Particle::Particle(string particleName, double Px = 0, double Py = 0, double Pz = 0) {
    fIndex = FindParticle(particleName);
    if (fIndex < 0)
        std::cout << "Particle " << particleName << " not found" << std::endl;
    fPx = Px;
    fPy = Py;
    fPz = Pz;
}

int Particle::GetIndex() const {
    return fIndex;
}

const ParticleType *Particle::GetParticleType() const {
    return fParticleType[fIndex];
}

void Particle::SetIndex(int index) {
    if (index >= fNParticleType) {
        std::cout << "Cannot set index " << index << ": out of bounds error" << std::endl;
        return;
    }
    fIndex = index;
}

void Particle::SetIndex(string particleName) {
    int index = FindParticle(particleName);
    if (index < 0) {
        std::cout << "Cannot set index for searched particle " << particleName << ": particle not found" << std::endl;
        return;
    }
    fIndex = index;
}

void Particle::AddParticleType(const string particleName, const double mass, const int charge, const double width) {
    if (fNParticleType >= fMaxNumParticleType) {
        std::cout << "Maximum number of particle types reached: cannot add new particle type" << std::endl;
        return;
    }

    const int index = FindParticle(particleName);
    if (index >= 0) {
        std::cout << "Particle type " << particleName << " already exists: cannot add duplicate" << std::endl;
        return;
    }

    fParticleType[fNParticleType] = width == 0 ? new ParticleType(particleName, mass, charge) : new ResonanceType(particleName, mass, charge, width);
    fNParticleType++;
}

void Particle::PrintParticleTypes() {
    for (int i = 0; i < fNParticleType; i++)
        fParticleType[i]->Print();
}

void Particle::Print() const {
    std::cout << fParticleType[fIndex]->GetName() << " [index = " << fIndex << "]" << std::endl <<
                 "\tP = (" << fPx << ", " << fPy << ", " << fPz << ")" << std::endl;
}

double Particle::GetPx() const {
    return fPx;
}

double Particle::GetPy() const {
    return fPy;
}

double Particle::GetPz() const {
    return fPz;
}

double Particle::GetMass() const {
    return fParticleType[fIndex]->GetMass();
}

double Particle::TotEnergy() const {
    return sqrt(pow(GetMass(), 2) + pow(fPx, 2) + pow(fPy, 2) + pow(fPz, 2));
}

double Particle::InvMass(Particle *p) const {
    return sqrt(pow(TotEnergy() + p->TotEnergy(), 2) - (pow(fPx + p->GetPx(), 2) + pow(fPy + p->GetPy(), 2) + pow(fPz + p->GetPz(), 2)));
}

void Particle::SetP(double Px, double Py, double Pz) {
    fPx = Px;
    fPy = Py;
    fPz = Pz;
}

int Particle::Decay2Body(Particle &dau1, Particle &dau2) const {
    if (GetMass() == 0.0) {
        printf("Decayment cannot be preformed if mass is zero\n");
        return 1;
    }

    double massMot = GetMass();
    double massDau1 = dau1.GetMass();
    double massDau2 = dau2.GetMass();

    // add width effect
    if (fIndex > -1) {
        // gaussian random numbers
        float x1, x2, w, y1, y2;

        double invnum = 1. / RAND_MAX;
        do {
            x1 = 2.0 * rand() * invnum - 1.0;
            x2 = 2.0 * rand() * invnum - 1.0;
            w = x1 * x1 + x2 * x2;
        } while (w >= 1.0);

        w = sqrt((-2.0 * log(w)) / w);
        y1 = x1 * w;
        y2 = x2 * w;

        massMot += fParticleType[fIndex]->GetWidth() * y1;
    }

    if (massMot < massDau1 + massDau2) {
        printf("Decayment cannot be preformed because mass is too low in this channel\n");
        return 2;
    }

    double pout = sqrt((massMot * massMot - (massDau1 + massDau2) * (massDau1 + massDau2)) * (massMot * massMot - (massDau1 - massDau2) * (massDau1 - massDau2))) / massMot * 0.5;

    double norm = 2 * M_PI / RAND_MAX;

    double phi = rand() * norm;
    double theta = rand() * norm * 0.5 - M_PI / 2.;
    dau1.SetP(pout * sin(theta) * cos(phi), pout * sin(theta) * sin(phi), pout * cos(theta));
    dau2.SetP(-pout * sin(theta) * cos(phi), -pout * sin(theta) * sin(phi), -pout * cos(theta));

    double energy = sqrt(fPx * fPx + fPy * fPy + fPz * fPz + massMot * massMot);

    double bx = fPx / energy;
    double by = fPy / energy;
    double bz = fPz / energy;

    dau1.Boost(bx, by, bz);
    dau2.Boost(bx, by, bz);

    return 0;
}

void Particle::Boost(double bx, double by, double bz) {
    double energy = TotEnergy();

    // Boost this Lorentz vector
    double b2 = bx * bx + by * by + bz * bz;
    double gamma = 1.0 / sqrt(1.0 - b2);
    double bp = bx * fPx + by * fPy + bz * fPz;
    double gamma2 = b2 > 0 ? (gamma - 1.0) / b2 : 0.0;

    fPx += gamma2 * bp * bx + gamma * bx * energy;
    fPy += gamma2 * bp * by + gamma * by * energy;
    fPz += gamma2 * bp * bz + gamma * bz * energy;
}
\end{minted}

\subsection*{GenerateParticles.cpp}
\begin{minted}[breaklines]{c}
#include "Particle.h"

#include "Parameters.h"
#include "ParticleType.h"
#include "ResonanceType.h"

#include <cmath>
#include <iostream>
#include <TH1D.h>
#include <TRandom3.h>
#include <TCanvas.h>
#include <TFile.h>
#include <TROOT.h>

void GenerateParticles() {
    // Initialization of particle types
    Particle::AddParticleType("π+", 0.13957, +1);
    Particle::AddParticleType("π-", 0.13957, -1);
    Particle::AddParticleType("K+", 0.49367, +1);
    Particle::AddParticleType("K-", 0.49367, -1);
    Particle::AddParticleType("p+", 0.93827, +1);
    Particle::AddParticleType("p-", 0.93827, -1);
    Particle::AddParticleType("K*", 0.89166, 0, 0.050);

    
    // Save histograms in root file
    TFile *file = new TFile("histograms.root", "RECREATE");

    // Histograms definitions
    TH1F *particleTypesH = new TH1F("particleTypesH", "Particle Types", N_PARTICLE_TYPES, 0, N_PARTICLE_TYPES);
    TH1F *finalParticleTypesH = new TH1F("finalParticleTypesH", "Final Particle Types", N_PARTICLE_TYPES, 0, N_PARTICLE_TYPES);
    TH1D *azimutAngleH = new TH1D("azimutAngleH", "Azimut Angle", N_BINS, 0, 2 * M_PI);
    TH1D *polarAngleH = new TH1D("polarAngleH", "Polar Angle", N_BINS, 0, M_PI);
    TH1D *momentumH = new TH1D("momentumH", "Momentum", N_BINS, 0, MAX_MOMENTUM);
    TH1D *transverseMomentumH = new TH1D("transverseMomentumH", "Transverse Momentum", N_BINS, 0, MAX_MOMENTUM);
    TH1D *particleEnergyH = new TH1D("particleEnergyH", "Particle Energy", N_BINS, 0, MAX_ENERGY);
    TH1D *invMassH = new TH1D("invMassH", "Invariant Mass", N_BINS_INV_MASS, MIN_INVARIANT_MASS, MAX_INVARIANT_MASS);
    TH1D *discordantInvMassH = new TH1D("discordantInvMassH", "Discordant Invariant Mass", N_BINS_INV_MASS, MIN_INVARIANT_MASS, MAX_INVARIANT_MASS);
    TH1D *concordantInvMassH = new TH1D("concordantInvMassH", "Concordant Invariant Mass", N_BINS_INV_MASS, MIN_INVARIANT_MASS, MAX_INVARIANT_MASS);
    TH1D *discordantPionKaonInvMassH = new TH1D("discordantPionKaonInvMassH", "Discordant Pion/Kaon Invariant Mass", N_BINS_INV_MASS, MIN_INVARIANT_MASS, MAX_INVARIANT_MASS);
    TH1D *concordantPionKaonInvMassH = new TH1D("concordantPionKaonInvMassH", "Concordant Pion/Kaon Invariant Mass", N_BINS_INV_MASS, MIN_INVARIANT_MASS, MAX_INVARIANT_MASS);
    TH1D *daughtersInvMassH = new TH1D("daughtersInvMassH", "Resonance Daughters Invariant Mass", N_BINS_INV_MASS, MIN_INVARIANT_MASS, MAX_INVARIANT_MASS);

    invMassH->Sumw2();
    discordantInvMassH->Sumw2();
    concordantInvMassH->Sumw2();
    discordantPionKaonInvMassH->Sumw2();
    concordantPionKaonInvMassH->Sumw2();
    daughtersInvMassH->Sumw2();

    // Variable definitions
    Particle particles[N_PARTICLE_TYPES + MAX_PRODUCTS];
    double phi, theta, P, rndm;
    double Px, Py, Pz;
    double invMass;

    int nDecayedParticles;  // Counter of decayed particles

    // Iterations
    for (int i = 0; i < N_ITERATIONS; i++) {

        // Reset decayed particles counter from previous iterations
        nDecayedParticles = 0;

        // Fill particles array
        for (int j = 0; j < N_PARTICLES_PER_ITERATION; j++) {

            // Random generation of momentum
            phi = gRandom->Uniform(0, 2*M_PI);
            theta = gRandom->Uniform(0, M_PI);
            P = gRandom->Exp(AVG_P);

            Px = P * sin(theta) * cos(phi);
            Py = P * sin(theta) * sin(phi);
            Pz = P * cos(theta);
            particles[j].SetP(Px, Py, Pz);

            // Random generate particle type and fill correspondent histogram
            rndm = gRandom->Rndm();
            if (rndm < PION_PLUS_CUMULATIVE) {
                particles[j].SetIndex("π+");
                particleTypesH->Fill(particleTypesH->GetBinCenter(PION_PLUS_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(PION_PLUS_BIN));
            } else if (rndm < PION_MINUS_CUMULATIVE) {
                particles[j].SetIndex("π-");
                particleTypesH->Fill(particleTypesH->GetBinCenter(PION_MINUS_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(PION_MINUS_BIN));
            } else if (rndm < KAON_PLUS_CUMULATIVE) {
                particles[j].SetIndex("K+");
                particleTypesH->Fill(particleTypesH->GetBinCenter(KAON_PLUS_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(KAON_PLUS_BIN));
            } else if (rndm < KAON_MINUS_CUMULATIVE) {
                particles[j].SetIndex("K-");
                particleTypesH->Fill(particleTypesH->GetBinCenter(KAON_MINUS_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(KAON_MINUS_BIN));
            } else if (rndm < PROTON_PLUS_CUMULATIVE) {
                particles[j].SetIndex("p+");
                particleTypesH->Fill(particleTypesH->GetBinCenter(PROTON_PLUS_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(PROTON_PLUS_BIN));
            } else if (rndm < PROTON_MINUS_CUMULATIVE) {
                particles[j].SetIndex("p-");
                particleTypesH->Fill(particleTypesH->GetBinCenter(PROTON_MINUS_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(PROTON_MINUS_BIN));
            } else {
                particles[j].SetIndex("K*");
                particleTypesH->Fill(particleTypesH->GetBinCenter(KAON_STAR_BIN));
                finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(KAON_STAR_BIN));

                // Decayment of K* in random pair (π+, K-) or (π-, K+)
                rndm = gRandom->Rndm();
                if (rndm < 0.5) {
                    particles[N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles].SetIndex("π+");
                    particles[N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles + 1].SetIndex("K-");
                    finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(PION_PLUS_BIN));
                    finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(KAON_MINUS_BIN));
                } else {
                    particles[N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles].SetIndex("π-");
                    particles[N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles + 1].SetIndex("K+");
                    finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(PION_MINUS_BIN));
                    finalParticleTypesH->Fill(finalParticleTypesH->GetBinCenter(KAON_PLUS_BIN));
                }
                particles[j].Decay2Body(particles[N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles], particles[N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles + 1]);
                nDecayedParticles++;
            }

            // Fill generation histograms
            azimutAngleH->Fill(phi);
            polarAngleH->Fill(theta);
            momentumH->Fill(P);
            transverseMomentumH->Fill(P * sin(theta));
            particleEnergyH->Fill(particles[j].TotEnergy());
        }

        // Compute invariant masses and fill histograms
        for (int j = 0; j < N_PARTICLES_PER_ITERATION + 2 * nDecayedParticles; j++) {
            
            // Alias particles[j] as p1
            const ParticleType *p1 = particles[j].GetParticleType();

            // Ignore K* particles for invariant mass histograms (charge == 0)
            if (p1->GetCharge() != 0) {
                
                // Iterate over all previous particles in the array
                for (int k = 0; k < j; k++) {
                    
                    // Alias particles[k] as p2
                    const ParticleType *p2 = particles[k].GetParticleType();
                    
                    // Ignore K* particles
                    if (p2->GetCharge() != 0) {

                        // Compute invariant mass and fill histogram
                        invMass = particles[j].InvMass(&particles[k]);
                        invMassH->Fill(invMass);
                        
                        // Fill discordant or concordant charge histogram
                        if (p1->GetCharge() != p2->GetCharge())
                            discordantInvMassH->Fill(invMass);
                        else
                            concordantInvMassH->Fill(invMass);

                        // Fill discordant or concordant pion-kaon histogram
                        if (     (p1->GetName() == "π+" && p2->GetName() == "K-") ||
                                 (p1->GetName() == "π-" && p2->GetName() == "K+") ||
                                 (p1->GetName() == "K+" && p2->GetName() == "π-") ||
                                 (p1->GetName() == "K-" && p2->GetName() == "π+"))
                            discordantPionKaonInvMassH->Fill(invMass);
                        else if ((p1->GetName() == "π+" && p2->GetName() == "K+") ||
                                 (p1->GetName() == "π-" && p2->GetName() == "K-") ||
                                 (p1->GetName() == "K+" && p2->GetName() == "π+") ||
                                 (p1->GetName() == "K-" && p2->GetName() == "π-"))
                            concordantPionKaonInvMassH->Fill(invMass);

                    }
                }
            }

            // Fill histogram with invariant masses of K* daughters
            if (j >= N_PARTICLES_PER_ITERATION && j % 2 == 0)
                daughtersInvMassH->Fill(particles[j].InvMass(&particles[j + 1]));
        }
    }

    file->Write();
    file->Close();
}
\end{minted}

\subsection*{AnalyzeData.cpp}
\begin{minted}[breaklines]{c}
#include "Parameters.h"

#include <TFile.h>
#include <TH1D.h>
#include <TF1.h>
#include <TMath.h>
#include <TFitResultPtr.h>
#include <TFitResult.h>
#include <TObject.h>
#include <TROOT.h>
#include <TStyle.h>
#include <TCanvas.h>
#include <iostream>
#include <cmath>

using namespace std;

void AnalyzeData() {
    gROOT->SetBatch();

    // Open root file and retrieve histograms
    TFile *file = new TFile("histograms.root", "READ");

    TH1D *particleTypesH = (TH1D*) file->Get("particleTypesH");
    TH1D *azimutAngleH = (TH1D*) file->Get("azimutAngleH");
    TH1D *polarAngleH = (TH1D*) file->Get("polarAngleH");
    TH1D *momentumH = (TH1D*) file->Get("momentumH");
    TH1D *discordantInvMassH = (TH1D*) file->Get("discordantInvMassH");
    TH1D *concordantInvMassH = (TH1D*) file->Get("concordantInvMassH");
    TH1D *discordantPionKaonInvMassH = (TH1D*) file->Get("discordantPionKaonInvMassH");
    TH1D *concordantPionKaonInvMassH = (TH1D*) file->Get("concordantPionKaonInvMassH");
    TH1D *daughtersInvMassH = (TH1D*) file->Get("daughtersInvMassH");

    // Set styles for histograms
    gStyle->SetOptStat("e");
    gStyle->SetOptFit(1111);
    particleTypesH->SetFillColor(kBlue);

    // Set axes labels
    particleTypesH->GetXaxis()->SetBinLabel(PION_PLUS_BIN, "#pi+");
    particleTypesH->GetXaxis()->SetBinLabel(PION_MINUS_BIN, "#pi-");
    particleTypesH->GetXaxis()->SetBinLabel(KAON_PLUS_BIN, "K+");
    particleTypesH->GetXaxis()->SetBinLabel(KAON_MINUS_BIN, "K-");
    particleTypesH->GetXaxis()->SetBinLabel(PROTON_PLUS_BIN, "p+");
    particleTypesH->GetXaxis()->SetBinLabel(PROTON_MINUS_BIN, "p+");
    particleTypesH->GetXaxis()->SetBinLabel(KAON_STAR_BIN, "K*");
    particleTypesH->GetYaxis()->SetTitle("Occurrences");

    azimutAngleH->GetXaxis()->SetTitle("Angle (rad)");
    polarAngleH->GetXaxis()->SetTitle("Angle (rad)");
    momentumH->GetXaxis()->SetTitle("Momentum (GeV/c)");
    discordantInvMassH->GetXaxis()->SetTitle("Mass (GeV/c^{2})");
    concordantInvMassH->GetXaxis()->SetTitle("Mass (GeV/c^{2})");
    discordantPionKaonInvMassH->GetXaxis()->SetTitle("Mass (GeV/c^{2})");
    concordantPionKaonInvMassH->GetXaxis()->SetTitle("Mass (GeV/c^{2})");
    daughtersInvMassH->GetXaxis()->SetTitle("Mass (GeV/c^{2})");

    azimutAngleH->GetYaxis()->SetTitle("Frequency Density");
    polarAngleH->GetYaxis()->SetTitle("Frequency Density");
    momentumH->GetYaxis()->SetTitle("Frequency Density");
    discordantInvMassH->GetYaxis()->SetTitle("Occurrences");
    concordantInvMassH->GetYaxis()->SetTitle("Occurrences");
    discordantPionKaonInvMassH->GetYaxis()->SetTitle("Occurrences");
    concordantPionKaonInvMassH->GetYaxis()->SetTitle("Occurrences");
    daughtersInvMassH->GetYaxis()->SetTitle("Frequency Density");

    // Output partile type occurrences for the report table
    cout << "Particle type occurrences:" << endl;
    for (int i = 1; i <= N_PARTICLE_TYPES; i++)
        cout << "\t" << LABELS[i - 1] << " " << particleTypesH->GetBinContent(i) << " +/- " << particleTypesH->GetBinError(i) << endl;

    // Convert occurrencies into frequency density
    azimutAngleH->Scale(1.0 / azimutAngleH->Integral("width"));
    polarAngleH->Scale(1.0 / polarAngleH->Integral("width"));
    momentumH->Scale(1.0 / momentumH->Integral("width"));
    daughtersInvMassH->Scale(1.0 / daughtersInvMassH->Integral("width"));
    
    // Fit histograms with the right distribution
    azimutAngleH->Fit("pol0", "Q");         // Uniform
    polarAngleH->Fit("pol0", "Q");          // Uniform
    momentumH->Fit("expo", "Q");            // Exponential
    daughtersInvMassH->Fit("gaus", "Q");    // Normal

    // Output mean for momentum fit distribution
    TF1 *momentumFit = momentumH->GetFunction("expo");
    double momentumFitMean = -1.0 / momentumFit->GetParameter(1);
    double momentumFitMeanError = abs(momentumFitMean * momentumFit->GetParError(1) / momentumFit->GetParameter(1));
    cout << "Momentum Exponential Fit:" << endl;
    cout << "\tMean: " << momentumFitMean << " +/- " << momentumFitMeanError << endl;

    // Check consistency of invariant mass histograms
    TH1D *pionKaonDiscordantMinusConcordantH = (TH1D*) discordantPionKaonInvMassH->Clone("pionKaonDiscordantMinusConcordantH");
    pionKaonDiscordantMinusConcordantH->Add(concordantPionKaonInvMassH, -1.0);
    pionKaonDiscordantMinusConcordantH->Fit("gaus", "Q");
    pionKaonDiscordantMinusConcordantH->SetTitle("Discordant-Concordant Pion/Kaon Invariant Mass Difference");

    TH1D *discordantMinusConcordantH = (TH1D*) discordantInvMassH->Clone("discordantMinusConcordantH");
    discordantMinusConcordantH->Add(concordantInvMassH, -1.0);
    discordantMinusConcordantH->Fit("gaus", "Q");
    discordantMinusConcordantH->SetTitle("Discordant-Concordant Invariant Mass Difference");

    // Save histograms in files for the final report
    TCanvas *c1 = new TCanvas();
    c1->Divide(2, 2);
    c1->cd(1);
    particleTypesH->Draw();
    c1->cd(2);
    azimutAngleH->Draw();
    c1->cd(3);
    polarAngleH->Draw();
    c1->cd(4);
    momentumH->Draw();
    c1->SaveAs("./histograms/typesAndMomentum.tikz.tex");

    gStyle->SetOptStat(0);
    TCanvas *c2 = new TCanvas("c2", "Invariant Mass", 600, 800);
    c2->Divide(1, 3);
    c2->cd(1);
    daughtersInvMassH->Draw();
    c2->cd(2);
    discordantMinusConcordantH->Draw();
    c2->cd(3);
    pionKaonDiscordantMinusConcordantH->Draw();
    c2->SaveAs("./histograms/invMass.tikz.tex");

    // Close root file
    file->Close();
}
\end{minted}
\end{document}
